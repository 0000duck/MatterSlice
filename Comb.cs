/*
This file is part of MatterSlice. A commandline utility for
generating 3D printing GCode.

Copyright (c) 2014, Lars Brubaker

MatterSlice is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using MatterSlice.ClipperLib;
using System;
using System.Collections.Generic;

#if false
namespace MatterHackers.MatterSlice
{
    using Polygon = List<IntPoint>;
    using Polygons = List<List<IntPoint>>;

    public class CombPath : List<IntPoint> //!< A single path either inside or outise the parts
    {
        bool throughAir = false; //!< Whether the path is one which moves through air.
        bool cross_boundary = false; //!< Whether the path crosses a boundary.
    }

    public class CombPaths : List<CombPath> //!< A list of paths alternating between inside a part and outside a part
    {
    }

/*!
 * Class for generating a combing move action from point a to point b and avoiding collision with other parts when moving through air.
 * See LinePolygonsCrossings::comb.
 * 
 * The general implementation is by rotating everything such that the the line segment from a to b is aligned with the x-axis.
 * We call the line on which a and b lie the 'scanline'.
 * 
 * The basic path is generated by following the scanline until it hits a polygon, then follow the polygon until the last point where it hits the scanline, 
 * follow the scanline again, etc.
 * The path is offsetted from the polygons, so that it doesn't intersect with them.
 * 
 * Next the basic path is optimized by taking shortcuts where possible. Only shortcuts which skip a single point are considered, in order to reduce computational complexity.
 */
public class LinePolygonsCrossings
{
        /*!
         * A Crossing holds data on a single point where a polygon crosses the scanline.
         */
        public struct Crossing
        {
            public static readonly int NO_INDEX = int.MaxValue;
            long x; //!< x coordinate of crossings between the polygon and the scanline.
            int point_idx; //!< The index of the first point of the line segment which crosses the scanline

            /*!
             * Creates a Crossing with minimal initialization
             * \param x The x-coordinate in transformed space
             * \param point_idx The index of the first point of the line segment which crosses the scanline
             */
            public Crossing(long x, int point_idx)
            {
                this.x = x;
                this.point_idx = point_idx;
            }
        }

        /*!
         * A PolyCrossings holds data on where a polygon crosses the scanline. Only the Crossing with lowest Crossing::x and highest are recorded.
         */
        public struct PolyCrossings
        {
            int poly_idx; //!< The index of the polygon which crosses the scanline
            Crossing min; //!< The point where the polygon first crosses the scanline.
            Crossing max; //!< The point where the polygon last crosses the scanline.
                          /*!
                           * Create a PolyCrossings with minimal initialization. PolyCrossings::min and PolyCrossings::max are not yet computed.
                           * \param poly_idx The index of the polygon in LinePolygonsCrossings::boundary
                           */
            public PolyCrossings(int poly_idx)

            {
                this.poly_idx = poly_idx;
                min = new Crossing(long.MaxValue, Crossing.NO_INDEX);
                max = new Crossing(long.MaxValue, Crossing.NO_INDEX);
            }
        }

        /*!
         * A PolyCrossings list: for every polygon a PolyCrossings.
         */
        class PartCrossings : List<PolyCrossings>
        {
            //int part_idx;
        }
    
    
    PartCrossings crossings; //!< All crossings of polygons in the LinePolygonsCrossings::boundary with the scanline.
    int min_crossing_idx; //!< The index into LinePolygonsCrossings::crossings to the crossing with the minimal PolyCrossings::min crossing of all PolyCrossings's.
    int max_crossing_idx; //!< The index into LinePolygonsCrossings::crossings to the crossing with the maximal PolyCrossings::max crossing of all PolyCrossings's.

    Polygons boundary; //!< The boundary not to cross during combing.
    IntPoint startPoint; //!< The start point of the scanline.
    IntPoint endPoint; //!< The end point of the scanline.

        long dist_to_move_boundary_point_outside; //!< The distance used to move outside or inside so that a boundary point doesn't intersect with the boundary anymore. Neccesary due to computational rounding problems. Use negative value for insicde combing.

    PointMatrix transformation_matrix; //!< The transformation which rotates everything such that the scanline is aligned with the x-axis.
    IntPoint transformed_startPoint; //!< The LinePolygonsCrossings::startPoint as transformed by Comb::transformation_matrix
    IntPoint transformed_endPoint; //!< The LinePolygonsCrossings::endPoint as transformed by Comb::transformation_matrix


    /*!
     * Check if we are crossing the boundaries, and pre-calculate some values.
     * 
     * Sets Comb::transformation_matrix, Comb::transformed_startPoint and Comb::transformed_endPoint
     * \return Whether the line segment from LinePolygonsCrossings::startPoint to LinePolygonsCrossings::endPoint collides with the boundary
     */
    bool lineSegmentCollidesWithBoundary();

    /*!
     * Calculate Comb::crossings, Comb::min_crossing_idx and Comb::max_crossing_idx.
     */
    void calcScanlineCrossings();

    /*! 
     * Get the basic combing path and optimize it.
     * 
     * \param combPath Output parameter: the points along the combing path.
     */
    void getCombingPath(CombPath& combPath, long max_comb_distance_ignored = MM2INT(1.5));

    /*! 
     * Get the basic combing path, without shortcuts. The path goes straight toward the endPoint and follows the boundary when it hits it, until it passes the scanline again.
     * 
     * Walk trough the crossings, for every boundary we cross, find the initial cross point and the exit point. Then add all the points in between
     * to the \p combPath and continue with the next boundary we will cross, until there are no more boundaries to cross.
     * This gives a path from the start to finish curved around the holes that it encounters.
     * 
     * \param combPath Output parameter: the points along the combing path.
     */
    void getBasicCombingPath(CombPath& combPath);

    /*! 
     * Get the basic combing path, following a single boundary polygon when it hits it, until it passes the scanline again.
     * 
     * Find the initial cross point and the exit point. Then add all the points in between
     * to the \p combPath and continue with the next boundary we will cross, until there are no more boundaries to cross.
     * This gives a path from the start to finish curved around the polygon that it encounters.
     * 
     * \param combPath Output parameter: where to add the points along the combing path.
     */
    void getBasicCombingPath(PolyCrossings& crossings, CombPath& combPath);

    /*!
     * Find the first polygon cutting the scanline after \p x.
     * 
     * Note that this function only looks at the first segment cutting the scanline (see Comb::minX)!
     * It doesn't return the next polygon which crosses the scanline, but the first polygon crossing the scanline for the first time.
     * 
     * \param x The point on the scanline from where to look.
     * \return The next PolyCrossings fully beyond \p x or one with PolyCrossings::poly_idx set to NO_INDEX if there's none left.
     */
    PolyCrossings* getNextPolygonAlongScanline(long x);

    /*!
     * Optimize the \p comb_path: skip each point we could already reach by not crossing a boundary. This smooths out the path and makes it skip some unneeded corners.
     * 
     * \param comb_path The unoptimized combing path.
     * \param optimized_comb_path Output parameter: The points of optimized combing path
     * \return Whether it turns out that the basic comb path already crossed a boundary
     */
    bool optimizePath(CombPath& comb_path, CombPath& optimized_comb_path);

    /*!
     * Create a LinePolygonsCrossings with minimal initialization.
     * \param boundary The boundary which not to cross during combing
     * \param start the starting point
     * \param end the end point
     * \param dist_to_move_boundary_point_outside Distance used to move a point from a boundary so that it doesn't intersect with it anymore. (Precision issue)
     */
    LinePolygonsCrossings(Polygons& boundary, IntPoint& start, IntPoint& end, long dist_to_move_boundary_point_outside)
    : boundary(boundary), startPoint(start), endPoint(end), dist_to_move_boundary_point_outside(dist_to_move_boundary_point_outside)
    {
    }

    public: 
    
    /*!
     * The main function of this class: calculate one combing path within the boundary.
     * \param boundary The polygons to follow when calculating the basic combing path
     * \param startPoint From where to start the combing move.
     * \param endPoint Where to end the combing move.
     * \param combPath Output parameter: the combing path generated.
     */
    static void comb(Polygons& boundary, IntPoint startPoint, IntPoint endPoint, CombPath& combPath, long dist_to_move_boundary_point_outside, long max_comb_distance_ignored = MM2INT(1.5))
    {
        LinePolygonsCrossings linePolygonsCrossings(boundary, startPoint, endPoint, dist_to_move_boundary_point_outside);
        linePolygonsCrossings.getCombingPath(combPath, max_comb_distance_ignored);
    };
};

class SliceDataStorage;

/*!
 * Class for generating a full combing actions from a travel move from a start point to an end point.
 * A single Comb object is used for each layer.
 * 
 * Comb::calc is the main function of this class.
 * 
 * Typical output: A combing path to the boundary of the polygon + a move through air avoiding other parts in the layer + a combing path from the boundary of the ending polygon to the end point.
 * Each of these three is a CombPath; the first and last are within Comb::boundary_inside while the middle is outside of Comb::boundary_outside.
 * Between these there is a little gap where the nozzle crosses the boundary of an object approximately perpendicular to its boundary.
 * 
 * As an optimization, the combing paths inside are calculated on specifically those PolygonsParts within which to comb, while the coundary_outside isn't split into outside parts, 
 * because generally there is only one outside part; encapsulated holes occur less often.
 */
class Comb
{
    friend class LinePolygonsCrossings;
    private:
    SliceDataStorage& storage; //!< The storage from which to compute the outside boundary, when needed.
    int layer_nr; //!< The layer number for the layer for which to compute the outside boundary, when needed.

        long offset_from_outlines; //!< Offset from the boundary of a part to the comb path. (nozzle width / 2)
        long max_moveInside_distance2; //!< Maximal distance of a point to the Comb::boundary_inside which is still to be considered inside. (very sharp corners not allowed :S)
        long offset_from_outlines_outside; //!< Offset from the boundary of a part to a travel path which avoids it by this distance.
    static const long max_moveOutside_distance2 = INT64_MAX; //!< Any point which is not inside should be considered outside.
    static const long offset_dist_to_get_from_on_the_polygon_to_outside = 40; //!< in order to prevent on-boundary vs crossing boundary confusions (precision thing)
    static const long offset_extra_start_end = 100; //!< Distance to move start point and end point toward eachother to extra avoid collision with the boundaries.

    bool avoid_other_parts; //!< Whether to perform inverse combing a.k.a. avoid parts.

    Polygons boundary_inside; //!< The boundary within which to comb.
    Polygons* boundary_outside; //!< The boundary outside of which to stay to avoid collision with other layer parts. This is a pointer cause we only compute it when we move outside the boundary (so not when there is only a single part in the layer)
    PartsView partsView_inside; //!< Structured indices onto boundary_inside which shows which polygons belong to which part. 

    /*!
     * Collects the inner most walls for every mesh in the layer (not support) or computes them from the outlines using Comb::offset_from_outlines.
     */
    Polygons getLayerSecondWalls();

    /*!
     * Get the boundary_outside, which is an offset from the outlines of all meshes in the layer. Calculate it when it hasn't been calculated yet.
     */
    Polygons* getBoundaryOutside();

    public:
    /*!
     * Initializes the combing areas for every mesh in the layer (not support)
     * \param storage Where the layer polygon data is stored
     * \param layer_nr The number of the layer for which to generate the combing areas.
     * \param offset_from_outlines The offset from the outline polygon, to create the combing boundary in case there is no second wall.
     * \param travel_avoid_other_parts Whether to avoid other layer parts when traveling through air.
     * \param travel_avoid_distance The distance by which to avoid other layer parts when traveling through air.
     */
    Comb(SliceDataStorage& storage, int layer_nr, long offset_from_outlines, bool travel_avoid_other_parts, long travel_avoid_distance);

    ~Comb();

    //! Utility function for `boundary_inside.inside(p)`.
    bool inside(const IntPoint p) { return boundary_inside.inside(p); }

/*!
 * Calculate the comb paths (if any) - one for each polygon combed alternated with travel paths
 * 
 * \param startPoint Where to start moving from
 * \param endPoint Where to move to
 * \param combPoints Output parameter: The points along the combing path, excluding the \p startPoint (?) and \p endPoint
 * \param startInside Whether we want to start inside the comb boundary
 * \param endInside Whether we want to end up inside the comb boundary
 * \return Whether combing has succeeded; otherwise a retraction is needed.
 */
bool calc(IntPoint startPoint, IntPoint endPoint, CombPaths& combPaths, bool startInside = false, bool endInside = false, long max_comb_distance_ignored = MM2INT(1.5));

/*!
 * Move \p p to inside the inner comb boundary with a \p distance from the boundary.
 * 
 * \param p the point to change/move
 * \param distance the distance from the resulting point to the boundary on the inside
 * \return whether the point has been moved inside
 */
bool moveInsideBoundary(IntPoint* p, int distance);
    
};

}//namespace cura

namespace cura
{

    bool Comb::moveInsideBoundary(IntPoint* p, int distance)
    {
        return PolygonUtils::moveInside(boundary_inside, *p, distance) != Crossing.NO_INDEX;
    }

    Polygons Comb::getLayerSecondWalls()
    {
        if (layer_nr < 0)
        { // when a raft is present
            return storage.raftOutline.offset(MM2INT(0.1));
        }
        else
        {
            Polygons layer_walls;
            for (SliceMeshStorage & mesh : storage.meshes)
            {
                for (SliceLayerPart & part : mesh.layers[layer_nr].parts)
                {
                    // we want the 2nd inner walls
                    if (part.insets.size() >= 2)
                    {
                        layer_walls.add(part.insets[1]);
                        continue;
                    }
                    // but we'll also take the inner wall if the 2nd doesn't exist
                    if (part.insets.size() >= 1)
                    {
                        layer_walls.add(part.insets[0]);
                        continue;
                    }
                    // and if there is no walls, we'll try to move inside from the outline
                    Polygons newOutline = part.outline.offset(-offset_from_outlines);
                    if (newOutline.polygonLength() > 0)
                    {
                        layer_walls.add(newOutline);
                        continue;
                    }
                    // offset_from_outlines was so large that it completely destroyed our isle,
                    // so we'll just use the regular outline
                    layer_walls.add(part.outline);
                    continue;
                }
            }
            return layer_walls;
        }
    }

    // boundary_outside is only computed when it's needed!
    Polygons* Comb::getBoundaryOutside()
    {
        if (!boundary_outside)
        {
            boundary_outside = new Polygons();
            *boundary_outside = storage.getLayerOutlines(layer_nr, false).offset(offset_from_outlines_outside);
        }
        return boundary_outside;
    }

    Comb::Comb(SliceDataStorage& storage, int layer_nr, long comb_boundary_offset, bool travel_avoid_other_parts, long travel_avoid_distance)
: storage(storage)
, layer_nr(layer_nr)
, offset_from_outlines(comb_boundary_offset) // between second wall and infill / other walls
, max_moveInside_distance2(offset_from_outlines* 2 * offset_from_outlines* 2)
, offset_from_outlines_outside(travel_avoid_distance)
, avoid_other_parts(travel_avoid_other_parts)
// , boundary_inside( boundary.offset(-offset_from_outlines) ) // TODO: make inside boundary configurable?
, boundary_inside(getLayerSecondWalls() )
, boundary_outside(nullptr)
, partsView_inside(boundary_inside.splitIntoPartsView() ) // !! changes the order of boundary_inside !!
{
}

Comb::~Comb()
{
    if (boundary_outside)
        delete boundary_outside;
}

bool Comb::calc(IntPoint startPoint, IntPoint endPoint, CombPaths& combPaths, bool startInside, bool endInside, long max_comb_distance_ignored)
{
    if (shorterThen(endPoint - startPoint, max_comb_distance_ignored))
    {
        return true;
    }



    //Move start and end point inside the comb boundary
    int start_inside_poly = Crossing.NO_INDEX;
    if (startInside)
    {
        start_inside_poly = PolygonUtils::moveInside(boundary_inside, startPoint, offset_extra_start_end, max_moveInside_distance2);
        if (!inside(start_inside_poly) || start_inside_poly == Crossing.NO_INDEX)
        {
            if (start_inside_poly != Crossing.NO_INDEX)
            { // if not yet inside because of overshoot, try again
                start_inside_poly = PolygonUtils::moveInside(boundary_inside, startPoint, offset_extra_start_end, max_moveInside_distance2);
            }
            if (start_inside_poly == Crossing.NO_INDEX)    //If we fail to move the point inside the comb boundary we need to retract.
            {
                startInside = false;
            }
        }
    }
    int end_inside_poly = Crossing.NO_INDEX;
    if (endInside)
    {
        end_inside_poly = PolygonUtils::moveInside(boundary_inside, endPoint, offset_extra_start_end, max_moveInside_distance2);
        if (!inside(endPoint) || end_inside_poly == Crossing.NO_INDEX)
        {
            if (end_inside_poly != Crossing.NO_INDEX)
            { // if not yet inside because of overshoot, try again
                end_inside_poly = PolygonUtils::moveInside(boundary_inside, endPoint, offset_extra_start_end, max_moveInside_distance2);
            }
            if (end_inside_poly == Crossing.NO_INDEX)    //If we fail to move the point inside the comb boundary we need to retract.
            {
                endInside = false;
            }
        }
    }


    int start_part_boundary_poly_idx;
    int end_part_boundary_poly_idx;
    int start_part_idx = (start_inside_poly == Crossing.NO_INDEX) ? Crossing.NO_INDEX : partsView_inside.getPartContaining(start_inside_poly, &start_part_boundary_poly_idx);
    int end_part_idx = (end_inside_poly == Crossing.NO_INDEX) ? Crossing.NO_INDEX : partsView_inside.getPartContaining(end_inside_poly, &end_part_boundary_poly_idx);

    if (startInside && endInside && start_part_idx == end_part_idx)
    { // normal combing within part
        PolygonsPart part = partsView_inside.assemblePart(start_part_idx);
        combPaths.emplace_back();
        LinePolygonsCrossings::comb(part, startPoint, endPoint, combPaths.back(), -offset_dist_to_get_from_on_the_polygon_to_outside, max_comb_distance_ignored);
        return true;
    }
    else
    { // comb inside part to edge (if needed) >> move through air avoiding other parts >> comb inside end part upto the endpoint (if needed) 
        IntPoint middle_from;
        IntPoint middle_to;
        IntPoint inside_middle_from;
        IntPoint inside_middle_to;

        if (startInside && endInside)
        {
            ClosestPolygonPoint middle_from_cp = PolygonUtils::findClosest(endPoint, boundary_inside[start_part_boundary_poly_idx]);
            ClosestPolygonPoint middle_to_cp = PolygonUtils::findClosest(middle_from_cp.location, boundary_inside[end_part_boundary_poly_idx]);
            //             walkToNearestSmallestConnection(middle_from_cp, middle_to_cp); // TODO: perform this optimization?
            middle_from = middle_from_cp.location;
            inside_middle_from = middle_from_cp.location;
            middle_to = middle_to_cp.location;
            inside_middle_to = middle_to_cp.location;
            PolygonUtils::moveInside(boundary_inside, inside_middle_from, offset_dist_to_get_from_on_the_polygon_to_outside, max_comb_distance_ignored); //Also move the intermediary waypoint inside if it isn't yet.
            PolygonUtils::moveInside(boundary_inside, inside_middle_to, offset_dist_to_get_from_on_the_polygon_to_outside, max_comb_distance_ignored);
        }
        else if (!startInside && !endInside)
        {
            middle_from = startPoint;
            inside_middle_from = startPoint;
            middle_to = endPoint;
            inside_middle_to = endPoint;
        }
        else if (!startInside && endInside)
        {
            middle_from = startPoint;
            inside_middle_from = startPoint;
            ClosestPolygonPoint middle_to_cp = PolygonUtils::findClosest(middle_from, boundary_inside[end_part_boundary_poly_idx]);
            middle_to = middle_to_cp.location;
            inside_middle_to = middle_to_cp.location;
            PolygonUtils::moveInside(boundary_inside, inside_middle_to, offset_dist_to_get_from_on_the_polygon_to_outside, max_comb_distance_ignored);
        }
        else if (startInside && !endInside)
        {
            middle_to = endPoint;
            inside_middle_to = endPoint;
            ClosestPolygonPoint middle_from_cp = PolygonUtils::findClosest(middle_to, boundary_inside[start_part_boundary_poly_idx]);
            middle_from = middle_from_cp.location;
            inside_middle_from = middle_from_cp.location;
            PolygonUtils::moveInside(boundary_inside, inside_middle_from, offset_dist_to_get_from_on_the_polygon_to_outside, max_comb_distance_ignored);
        }

        if (startInside)
        {
            // start to boundary
            PolygonsPart part_begin = partsView_inside.assemblePart(start_part_idx); // comb through the starting part only
            combPaths.emplace_back();
            LinePolygonsCrossings::comb(part_begin, startPoint, inside_middle_from, combPaths.back(), -offset_dist_to_get_from_on_the_polygon_to_outside, max_comb_distance_ignored);
        }

        // throught air from boundary to boundary
        if (avoid_other_parts)
        {
            Polygons & middle = *getBoundaryOutside(); // comb through all air, since generally the outside consists of a single part
            IntPoint from_outside = middle_from;
            if (startInside || middle.inside(from_outside, true))
            { // move outside
                PolygonUtils::moveInside(middle, from_outside, -offset_extra_start_end, max_moveInside_distance2);
            }
            IntPoint to_outside = middle_to;
            if (endInside || middle.inside(to_outside, true))
            { // move outside
                PolygonUtils::moveInside(middle, to_outside, -offset_extra_start_end, max_moveInside_distance2);
            }
            combPaths.emplace_back();
            combPaths.back().throughAir = true;
            if (vSize(inside_middle_from - inside_middle_to) < vSize(inside_middle_from - from_outside) + vSize(inside_middle_to - to_outside))
            { // via outside is a detour
                combPaths.back().push_back(inside_middle_from);
                combPaths.back().push_back(inside_middle_to);
            }
            else
            {
                LinePolygonsCrossings::comb(middle, from_outside, to_outside, combPaths.back(), offset_dist_to_get_from_on_the_polygon_to_outside, max_comb_distance_ignored);
            }
        }
        else
        { // directly through air (not avoiding other parts)
            combPaths.emplace_back();
            combPaths.back().throughAir = true;
            combPaths.back().cross_boundary = true; // TODO: calculate whether we cross a boundary!
            combPaths.back().push_back(inside_middle_from);
            combPaths.back().push_back(inside_middle_to);
        }

        if (endInside)
        {
            // boundary to end
            PolygonsPart part_end = partsView_inside.assemblePart(end_part_idx); // comb through end part only
            combPaths.emplace_back();
            LinePolygonsCrossings::comb(part_end, inside_middle_to, endPoint, combPaths.back(), -offset_dist_to_get_from_on_the_polygon_to_outside, max_comb_distance_ignored);
        }

        return true;
    }
}

void LinePolygonsCrossings::calcScanlineCrossings()
{

    min_crossing_idx = Crossing.NO_INDEX;
    max_crossing_idx = Crossing.NO_INDEX;

    for (int poly_idx = 0; poly_idx < boundary.size(); poly_idx++)
    {
        PolyCrossings minMax(poly_idx);
        PolygonRef poly = boundary[poly_idx];
        IntPoint p0 = transformation_matrix.apply(poly[poly.size() - 1]);
        for (int point_idx = 0; point_idx < poly.size(); point_idx++)
        {
            IntPoint p1 = transformation_matrix.apply(poly[point_idx]);
            if ((p0.Y >= transformed_startPoint.Y && p1.Y <= transformed_startPoint.Y) || (p1.Y >= transformed_startPoint.Y && p0.Y <= transformed_startPoint.Y))
            {
                if (p1.Y == p0.Y) //Line segment is parallel with the scanline. That means that both endpoints lie on the scanline, so they will have intersected with the adjacent line.
                {
                    p0 = p1;
                    continue;
                }
                long x = p0.X + (p1.X - p0.X) * (transformed_startPoint.Y - p0.Y) / (p1.Y - p0.Y);

                if (x >= transformed_startPoint.X && x <= transformed_endPoint.X)
                {
                    if (x < minMax.min.x) //For the leftmost intersection, move x left to stay outside of the border.
                                          //Note: The actual distance from the intersection to the border is almost always less than dist_to_move_boundary_point_outside, since it only moves along the direction of the scanline.
                    {
                        minMax.min.x = x;
                        minMax.min.point_idx = point_idx;
                    }
                    if (x > minMax.max.x) //For the rightmost intersection, move x right to stay outside of the border.
                    {
                        minMax.max.x = x;
                        minMax.max.point_idx = point_idx;
                    }
                }
            }
            p0 = p1;
        }

        if (minMax.min.point_idx != Crossing.NO_INDEX)
        { // then also max.point_idx != -1
            if (min_crossing_idx == Crossing.NO_INDEX || minMax.min.x < crossings[min_crossing_idx].min.x) { min_crossing_idx = crossings.size(); }
            if (max_crossing_idx == Crossing.NO_INDEX || minMax.max.x > crossings[max_crossing_idx].max.x) { max_crossing_idx = crossings.size(); }
            crossings.push_back(minMax);
        }

    }
}


bool LinePolygonsCrossings::lineSegmentCollidesWithBoundary()
{
    IntPoint diff = endPoint - startPoint;

    transformation_matrix = PointMatrix(diff);
    transformed_startPoint = transformation_matrix.apply(startPoint);
    transformed_endPoint = transformation_matrix.apply(endPoint);

    for (PolygonRef poly : boundary)
    {
        IntPoint p0 = transformation_matrix.apply(poly.back());
        for (IntPoint p1_ : poly)
        {
            IntPoint p1 = transformation_matrix.apply(p1_);
            if ((p0.Y > transformed_startPoint.Y && p1.Y < transformed_startPoint.Y) || (p1.Y > transformed_startPoint.Y && p0.Y < transformed_startPoint.Y))
            {
                long x = p0.X + (p1.X - p0.X) * (transformed_startPoint.Y - p0.Y) / (p1.Y - p0.Y);

                if (x > transformed_startPoint.X && x < transformed_endPoint.X)
                    return true;
            }
            p0 = p1;
        }
    }

    return false;
}


void LinePolygonsCrossings::getCombingPath(CombPath& combPath, long max_comb_distance_ignored)
{
    if (shorterThen(endPoint - startPoint, max_comb_distance_ignored) || !lineSegmentCollidesWithBoundary())
    {
        //We're not crossing any boundaries. So skip the comb generation.
        combPath.push_back(startPoint);
        combPath.push_back(endPoint);
        return;
    }

    calcScanlineCrossings();

    CombPath basicPath;
    getBasicCombingPath(basicPath);
    optimizePath(basicPath, combPath);
}


void LinePolygonsCrossings::getBasicCombingPath(CombPath& combPath)
{
    for (PolyCrossings* crossing = getNextPolygonAlongScanline(transformed_startPoint.X)
        ; crossing != nullptr
        ; crossing = getNextPolygonAlongScanline(crossing->max.x))
    {
        getBasicCombingPath(*crossing, combPath);
    }
    combPath.push_back(endPoint);
}

void LinePolygonsCrossings::getBasicCombingPath(PolyCrossings& polyCrossings, CombPath& combPath)
{
    PolygonRef poly = boundary[polyCrossings.poly_idx];
    combPath.push_back(transformation_matrix.unapply(IntPoint(polyCrossings.min.x + dist_to_move_boundary_point_outside, transformed_startPoint.Y)));
    if ((polyCrossings.max.point_idx - polyCrossings.min.point_idx + poly.size()) % poly.size()
        < poly.size() / 2)
    { // follow the path in the same direction as the winding order of the boundary polygon
        for (int point_idx = polyCrossings.min.point_idx
            ; point_idx != polyCrossings.max.point_idx
            ; point_idx = (point_idx < poly.size() - 1) ? (point_idx + 1) : (0))
        {
            combPath.push_back(PolygonUtils::getBoundaryPointWithOffset(poly, point_idx, dist_to_move_boundary_point_outside));
        }
    }
    else
    { // follow the path in the opposite direction of the winding order of the boundary polygon
        int min_idx = (polyCrossings.min.point_idx == 0) ? poly.size() - 1 : polyCrossings.min.point_idx - 1;
        int max_idx = (polyCrossings.max.point_idx == 0) ? poly.size() - 1 : polyCrossings.max.point_idx - 1;

        for (int point_idx = min_idx; point_idx != max_idx; point_idx = (point_idx > 0) ? (point_idx - 1) : (poly.size() - 1))
        {
            combPath.push_back(PolygonUtils::getBoundaryPointWithOffset(poly, point_idx, dist_to_move_boundary_point_outside));
        }
    }
    combPath.push_back(transformation_matrix.unapply(IntPoint(polyCrossings.max.x - dist_to_move_boundary_point_outside, transformed_startPoint.Y)));
}



LinePolygonsCrossings::PolyCrossings* LinePolygonsCrossings::getNextPolygonAlongScanline(long x)
{
    PolyCrossings* ret = nullptr;
    for (PolyCrossings & crossing : crossings)
    {
        if (crossing.min.x > x && (ret == nullptr || crossing.min.x < ret->min.x))
        {
            ret = &crossing;
        }
    }
    return ret;
}

bool LinePolygonsCrossings::optimizePath(CombPath& comb_path, CombPath& optimized_comb_path)
{
    optimized_comb_path.push_back(startPoint);
    for (int point_idx = 1; point_idx < comb_path.size(); point_idx++)
    {
        if (comb_path[point_idx] == comb_path[point_idx - 1]) //Two points are the same. Skip the second.
        {
            continue;
        }
        IntPoint & current_point = optimized_comb_path.back();
        if (PolygonUtils::polygonCollidesWithlineSegment(boundary, current_point, comb_path[point_idx]))
        {
            if (PolygonUtils::polygonCollidesWithlineSegment(boundary, current_point, comb_path[point_idx - 1]))
            {
                comb_path.cross_boundary = true;
            }
            optimized_comb_path.push_back(comb_path[point_idx - 1]);
        }
        else
        {
            // : dont add the newest point

            // TODO: add the below extra optimization? (+/- 7% extra computation time, +/- 2% faster print for Dual_extrusion_support_generation.stl)
            while (optimized_comb_path.size() > 1)
            {
                if (PolygonUtils::polygonCollidesWithlineSegment(boundary, optimized_comb_path[optimized_comb_path.size() - 2], comb_path[point_idx]))
                {
                    break;
                }
                else
                {
                    optimized_comb_path.pop_back();
                }
            }
        }
    }
    return true;
}

}//namespace cura
}
#endif